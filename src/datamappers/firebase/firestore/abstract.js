import { db } from "@/datamappers/firebase/firebase";

class AbstractkMapper {
  constructor(collectionName, object, key) {
    this.collectionName = collectionName;
    this.objectToSave = object;
    this.key = key;

    this.request = {
      pending: false
    };

    this.docsArray = [];
  }
  // ToDo: Create document without custom key (fsdb autogenerated)
  // ToDo: AM can catch exception if custom key is not unique
  // and create one with auto-generated (fsdb autogenerated)

  // CRUD methods
  // Saves new document to a given firestore document collection
  async createDoc() {
    try {
      // Create new document in given collection from object
      // with user defined key/id
      await db
        .collection(this.collectionName)
        .doc(this.key)
        .set(this.objectToSave);
      console.log("Created new document in firestore.");
    } catch (error) {
      console.log(this);
      console.log(
        `Unexpected error on saving track meta... Error message: ${error.message}`
      );
    }
  }

  // Updates entire existing document
  async updateDoc() {
    console.log("updateDoc in abstract");
    console.log(this.objectToSave);
    try {
      // Can partly update document
      // Definition due to this.objectToSave
      await db
        .collection(this.collectionName)
        .doc(this.key)
        .update(this.objectToSave);
      console.log("Document updated in firestore.");
    } catch (error) {
      console.log(
        `Unexpected error on updating track meta... Error message: ${error.message}`
      );
    }
  }

  // Get methods
  // return back abstract entity objects, caller can deal with
  async getDocs(params) {
    console.log("getDocs() in abstract1");
    const p = params;
    // If source not set, try alternatively read from pre-defined collection
    // Only for tracks source should to be passed via getDocs
    if (!p.source) {
      p.source = this.collectionName;
    }
    if (p.numberOfItems) {
      await this.findNext(p);
    } else {
      await this.findAll(p);
    }
    console.log(this.docsArray);
    return this.docsArray;
  }

  async getDoc(key) {
    let doc = {};
    try {
      // Avoid sending muliple calls at a time
      if (this.request.pending) {
        console.log("Request is already pending");
        return;
      }
      this.request.pending = true;

      const fsdb = db.collection(this.collectionName);
      console.log(this.collectionName);
      doc = await fsdb.doc(key).get();
      console.log(doc.data());

      this.request.pending = false;
    } catch (error) {
      console.log(`Error while quering tags from database: ${error.message}`);
    }
    // eslint-disable-next-line consistent-return
    return { ...doc.data() };
  }

  // Find helper methods
  async findAll(params) {
    try {
      console.log("findAll in abstract1");
      // Avoid sending muliple calls at a time
      if (this.request.pending) {
        console.log("Request is already pending");
        return;
      }
      this.request.pending = true;
      console.log(params.source);
      const docSnapshots = await db
        .collection(params.source)
        .orderBy(params.sortOnColumn)
        .get();
      docSnapshots.forEach(docSnapshot => {
        const doc = {
          ...docSnapshot.data()
        };
        this.docsArray.push(doc);
      });
      this.request.pending = false;
    } catch (error) {
      console.log(`Error while quering tags from database: ${error.message}`);
    }
    console.log("findAll in abstract2");
  }

  async findNext(params) {
    try {
      // Avoid sending muliple calls at a time
      if (this.request.pending) {
        console.log("Request is already pending");
        return;
      }
      this.request.pending = true;

      let docSnapshots;
      console.log(params.source);
      console.log(params);
      if (params.startAfterKey) {
        console.log(
          `Quering firebase with findNext. Start after:${params.startAfterKey}`
        );
        const startAfterDoc = await db
          .collection(params.source)
          .doc(params.startAfterKey)
          .get();

        docSnapshots = await db
          .collection(params.source)
          .orderBy(params.sortOnColumn)
          .startAfter(startAfterDoc)
          .limit(params.numberOfItems)
          .get();
      } else {
        console.log("Quering firebase with findNext. Start from beginning.");
        docSnapshots = await db
          .collection(params.source)
          .orderBy(params.sortOnColumn)
          .limit(params.numberOfItems)
          .get();
      }
      console.log(docSnapshots);
      docSnapshots.forEach(docSnapshot => {
        const doc = {
          ...docSnapshot.data()
        };
        this.docsArray.push(doc);
      });
      this.request.pending = false;
    } catch (error) {
      console.log(`Error while quering tags from database: ${error.message}`);
    }
  }

  // Helper and checker
  // ToDo: checkCustomKey returns true if
  // to use on CreateDoc
  // Alg: use find doc on key in fsdb
}

export default AbstractkMapper;
